# 스프링부트 동작원리

---

## ■ 내장 톰캣(Tomcat)을 가진다

- 톰캣을 따로 설치할 필요없이 바로 실행이 가능하다.
- Tomcat?

  > `아파치 톰캣`은 아파치 소프트웨어 재단에서 개발한 서블릿 컨테이너만 있는 `웹 애플리케이션 서버`이다. 톰캣은 웹 서버와 연동하여 실행할 수 있는 자바 환경을 제공하여 자바서버 페이지와 자바 서블릿이 실행할 수 있는 환경을 제공하고 있다.
  >

  아파치는 html, css, .png와 같은 정적 파일에 대한 요청에만 응답한다.

  아파치는 자바 코드를 포함한 요청에 대한 응답을 할 수 없다. (java코드를 읽을 수 없기 때문)

  자바코드가 포함된 파일(JSP) 요청이 들어올 시 제어권을 Tomcat에게 넘기고 톰캣은 자바파일을 컴파일한다. 톰캣은 컴파일 된 데이터를 html 문서로 변환하여 아파치에게 전달한다. 마지막으로 아파치는 톰캣에게 전달받은 html문서를 응답한다.


---

## ■  서블릿 컨테이너 (Servlet Container)

- **웹 애플리케이션 서버** 중에서 **HTTP요청을 받아 처리**하는 기초 역할을 한다.
- 대부분의 웹 프레임워크가 제공하는 기능은 **서블릿 컨테이너 위에서 동작**하는 `서블릿`, `필터`, `이벤트 리스너` 등을 적절하게 구현한 것이다.
- 즉, 사용자가 웹 프레임워크로 작성한 웹 애플리케이션은 서블릿 컨테이너 위에서 동작한다.
- **아파치 톰캣(Tomcat)**, **제티(Jetty)** 등이 서블릿 컨테이너 이다.

  ![출처 : [https://minwan1.github.io/2018/11/21/2018-11-21-jsp-springboot-동작과정/](https://minwan1.github.io/2018/11/21/2018-11-21-jsp-springboot-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95/)](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d370be05-1ac9-4a77-a6cf-879e8837501a/Untitled.png)

  출처 : [https://minwan1.github.io/2018/11/21/2018-11-21-jsp-springboot-동작과정/](https://minwan1.github.io/2018/11/21/2018-11-21-jsp-springboot-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95/)

  1. 클라리언트의 최초 요청 시 `서블릿` 객체를 생성한다. - init() 메서드 호출
  2. service() 메서드 호출 - POST, GET, PUT, DELETE 식별 (새로운 스레드가 생성되어 실행)
  3. POST, GET, PUT, DELETE 요청에 알맞은 메서드 호출
  4. 요청(request)에 대한 응답(response)이 완료되면 스레드는 종료 (제거하지 않음)
  5. 스레드에 생성에 제한이 걸려 대기중인 요청은 종료된 스레드를 재사용 (Pooling 기법)

    ---

  `Scale-up`: 컴퓨터의 성능을 높여 최대 스레드의 개수를 늘리는 방법

  `Scale-out`: 컴퓨터의 개수를 늘려 분산처리하는 방법

- 스프링은 URI 접근 방식만 허용 (URL로 특정한 파일 요청을 할 수 없다.)
  즉, 요청 시에는 무조건 자바를 거친다. (Tomcat을 거친다.)

---

## ■  Web.xml (웹 배포 서술자, Deployment Descriptor)

- `**ServletContext`의 초기 파라미터 설정**
  - 애플리케이션내 모든 컴포넌트가 사용할 수 있는 초기 파라미터이다.
  - `ServetConfig`의 단점을 보완하여 개발된 파라미터이다.

    [서블릿 초기화 파라미터 (ServletConfig)](https://m.blog.naver.com/crazybnn/30099209553)


- `**Session`의 유효기간 설정**

- **Servlet/JSP에 대한 정의 및 매핑**
  - 클라이언트가 요청한 URI에 대하여 실제 자원의 위치를 정의에 따라 매핑
  - 매핑 시 (web.xml에 직접 매핑, @WebServlet 어노테이션 사용) 모든 클래스에 매핑을 적용시키기에는 코드가 너무 복잡해지기 때문에 `FrontController` 패턴을 이용한다.

- **`Mime Type` 매핑**
  - Mime Type(Multipurpose Internet Extensions): 바이너리 데이터인 첨부파일을 아스키코드로 인코딩하기 위해 사용되는 기법

    [MIME 타입 - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

    웹을 통해 HTTP통신에서 전달되는 다양한 형태의 데이터를 표현하기 위해 사용된다.

      <aside>
      ✨ Mime타입, 데이터없이 접근하는 클라이언트는 HTTP 통신의 GET 방식을 사용

      </aside>

- **Welcome File list**
- **Error Pages 처리**
  - 유효하지 않은 요청을 가지고 서버에 접근했을 때의 처리방법
- **리스너/필터 설정**
  - 필터: 클라이언트의 요청에서 특정 데이터를 걸러내어 제거하는 방법
  - 리스너

    [[서블릿/JSP] 리스너(Listner)란? 이벤트 리스너의 개념 설명. 구현 및 등록하기](https://dololak.tistory.com/616)

- **보안**

---

## ■  FrontController 패턴

- 최초 앞단에서 request를 받아 필요한 클래스에 넘겨준다.
  web.xml에 모든 request에 해당하는 response값을 정의하기 힘들기 때문
- 클라이언트 → 톰캣 → 자원 의 순서로 request, response 할 때,
  클라이언트 → 톰캣 에서 request, response 객체가 생성되는데 해당 정보와
  톰캣 → 자원 에서 새로운 요청으로 생겨난 request, response 객체의 정보가 다른 상황이 발생한다.
- 혹은 클라이언트가 서버에게 A.jsp 를 요청하여 A.html 이라는 응답을 받은 후 어떠한 정보를 가지고 b.jsp를 요청했을 때, 새로운 request 객체가 생성되면서 기존의 request 객체에 저장된 정보를 잃어버리는 상황이 발생한다.
- 즉, 요청과 응답 사이에 클라이언트의 정보를 잃어버리게 되는데 이를 보완하고자 클라이언트 → 톰캣 에서 생성된 request, response 객체의 정보를 그대로 유지시켜주는 기법인 `RequestDispatcher` 가 생겨났다.

---

## ■  RequestDispatcher

- 필요한 클래스에 대한 요청이 도달했을 때 `FrontController`에 도착한 `request`와 `response` 정보를 그대로 유지시켜준다.
- `RequestDispatcher`를 사용하면 페이지 간 데이터 이동이 가능!
  - 클라이언트가 서버에게 A.jsp 를 요청하여 A.html 이라는 응답을 받은 후 어떠한 정보를 가지고 b.jsp를 요청했을 때, 새로운 request 객체가 생성되면서 기존의 request 객체에 저장된 정보를 잃어버리는 상황이 발생했을 때,

    RequestDispatcher를 사용하면 A.html의 정보를 B.html에서도 사용할 수 있게 된다.
    B.jsp를 요청했을 때 의 request 객체는 새로운 객체를 생성하는 것이 아닌 기존의 객체를 재사용 하기 때문이다.


---

## ■  DispatchServlet

- Spring에서 제공하는 `FrontController 패턴` + `RequestDispatcher`의 기능을 수행하는 기술
- DispatchServlet이 자동생성되어 질 때 수 많은 객체가 생성(IoC) 된다.(Controller, Repository, Bean, … ) 이는 보통 필터들이고 해당 필터들은 기본적으로 필요한 자동으로 등록되고, 개발자가 추가적인 필터를 직접 등록할 수도 있다.

## 알아두면 좋은 기타 개념 정리

---

### HTTP 해외문서 번역

[HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP)

---

### Socket 통신 VS Http 통신

- Socket 통신
  - `Socket`: 운영체제가 가지고 있음. 네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의 엔드 포인트
  - 연결을 성공하면 소켓을 종료하고 스레드를 오픈하여 양방향 통신을 진행한다.
  - 소켓통신의 단점: 두 개의 프로그램간 연결이 끊어지지 않기 때문에 부하가 크다.

- Http 통신
  - html 확장자로 만들어진 문서를 필요한 사람에게 연결없이 제공하는 방식
  - URL(IP주소, 요청자원..)에 따른 정적 자원 요청에 대해 소켓을 사용하여 응답을 해준다.
  - `Stateless` 방식 사용

    A 프로그램에서 a.txt 파일을 요청 했을 때, 소켓에서 새로운 스레드를 생성하지 않고 a.txt파일을 응답하고 소켓을 끊는다.

  - Http 통신의 단점: 요청이 들어올 때마다 항상 새로운 프로그램이라고 인식한다.

---

### URL vs URI (Uniform Resourse Identifier vs Locator)

- URI (Identifier): 통합 자원 식별자이다. 논리적, 물리적 리소스를 식별한다.
- URL (locator): 웹 주소라고도 하며, 네트워크 상 리소스가 어디 있는지 알려주기 위한 규악

    ```java
    URI    http://www.charlezz.com/index          (식별자)
    URL    http://www.charlezz.com/index.html     (파일 위치)
    ```


---

### 솔리드 프로젝트(Soild)

- WWW(World Wide Wep)의 창시자인 팀버너스리가 주도하는 웹 탈중심화 프로젝트
- 데이터를 중앙 집중화 시키지 않고 분산 시키는 웹 블록체인과 유사함

---

### 시스템 콜

- 운영체제가 제공하는 인터페이스 커널영역의 기능을 사용자 모드가 사용 가능하게 함
- 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스
- ex) Http 통신을 위해 운영체제가 가지고 있는 소켓을 사용하는 것